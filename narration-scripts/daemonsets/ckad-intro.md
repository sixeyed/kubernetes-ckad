Excellent work on the hands-on exercises! You've now practiced creating DaemonSets, deploying them with HostPath volumes, working with init containers, using node selectors to control placement, and understanding how updates behave differently from Deployments. That foundation is solid, and now we're going to shift our focus to what the CKAD exam expects you to know about DaemonSets.

Here's the key thing to understand: DaemonSets are less frequently tested than Deployments, but they do appear in exam scenarios, especially for node-level services like logging or monitoring agents. The exam doesn't just test whether you can create a DaemonSet, it tests whether you recognize when the requirements call for a DaemonSet instead of a Deployment. That pattern recognition is what we're going to develop in this section.

Let's talk about the CKAD exam requirements for DaemonSets. You need to understand DaemonSet creation and management, including the differences between DaemonSets and Deployments at a fundamental level. The exam covers update strategies extensively, both RollingUpdate which updates automatically and OnDelete which requires manual Pod deletion for controlled rollouts. You'll need to be comfortable with node selection using nodeSelector for simple cases and node affinity for more complex requirements, plus understanding how taints and tolerations work to allow DaemonSets on nodes that would normally reject Pods. Init containers in DaemonSet Pods come up regularly, as do HostPath volumes and their security considerations, which we'll explore in depth.

Starting with DaemonSet basics, you need to understand that DaemonSets ensure exactly one Pod runs on each node, or on a subset of nodes when you use node selectors. Unlike Deployments where you specify replica counts, Kubernetes automatically creates Pods based on the number of matching nodes. The basic DaemonSet spec is nearly identical to a Deployment, which is important for the rapid creation techniques we'll practice.

The update strategies section is critical for the exam. RollingUpdate is the default strategy where Pods are updated automatically when the DaemonSet spec changes, controlled by the maxUnavailable parameter that determines how many nodes can be updating simultaneously. OnDelete strategy gives you manual control, where the DaemonSet is updated but Pods remain unchanged until you explicitly delete them, allowing node-by-node rollouts with verification between each step. We'll compare RollingUpdate versus OnDelete with practical examples so you understand when to choose each approach.

Node selection is another frequent exam topic. You'll use nodeSelector for simple label-based selection, like running only on nodes with SSD storage or in specific availability zones. Node affinity provides more expressive selection with required and preferred rules, using operators like In, NotIn, Exists, and DoesNotExist. Tolerations for tainted nodes are essential because they allow DaemonSet Pods to run on nodes that would normally reject them, which is critical for system-level services. Running DaemonSets on master or control plane nodes requires specific tolerations for taints like node-role.kubernetes.io/master or node-role.kubernetes.io/control-plane, and we'll practice this pattern.

Init containers in DaemonSets follow the same patterns as other workloads but are particularly common for node-level services that need setup tasks before the main application starts. You'll see init container failure and retry behavior, where failed init containers restart with exponential backoff until they succeed. Understanding this retry mechanism helps you debug Pods stuck in Init status during the exam.

HostPath volumes are one of the most important topics for DaemonSets. They allow access to node resources like log directories, container runtime sockets, or host metrics from /proc and /sys. Security considerations around HostPath are crucial because unrestricted access can compromise the entire node. We'll examine the security risks of unrestricted HostPath access, including scenarios where containers can read sensitive host files or even escape to the underlying node. Common HostPath use cases include log collection from /var/log, accessing the container runtime socket, gathering host metrics, and reading certificate stores, each with appropriate security settings.

Host networking and ports add another dimension to DaemonSets. Host network mode puts the Pod directly on the node's network namespace, which is necessary for network plugins and some monitoring tools. Host ports expose container ports on the node even without host networking, commonly used for metrics exporters. We'll compare hostNetwork versus hostPort so you understand when each is appropriate and how they interact with DNS and networking.

Pod affinity with DaemonSets enables advanced patterns. You can co-locate Pods with DaemonSet Pods using pod affinity rules, which is useful for debugging scenarios where you need to access the same HostPath volumes. You can also avoid DaemonSet Pods using pod anti-affinity, spreading workloads away from resource-intensive DaemonSet Pods. Debugging with pod affinity is a practical technique for troubleshooting DaemonSet issues without disrupting the running service.

Resource management for DaemonSets requires careful consideration because they run on every node. Setting resource requests and limits is essential to prevent DaemonSet Pods from starving application workloads. Priority classes for DaemonSets, especially system-node-critical and system-cluster-critical, ensure that important system services can preempt lower-priority Pods when node resources are constrained. Priority class preemption examples show how high-priority DaemonSets can evict normal-priority Pods to ensure system services remain available.

Understanding the differences between DaemonSets and Deployments is fundamental for exam success. The decision tree helps you choose: when you need one Pod per node or node-specific access, use a DaemonSet; when you need a specific replica count or horizontal scaling, use a Deployment. Knowing when to use each controller based on the requirements is often the entire question.

Troubleshooting DaemonSets involves recognizing common issues like Pods not scheduling due to node selector mismatches or missing tolerations, updates getting stuck because of invalid images or resource constraints, and Pods appearing on wrong nodes due to affinity misconfiguration. Debugging commands like kubectl rollout status, kubectl describe, and checking Pod events are essential skills. We'll walk through a troubleshooting scenario for a failed update, showing you the systematic approach to identify problems, check rollout history, fix issues either by rolling back or applying corrections, and verify the resolution.

The lab exercises provide hands-on practice with exam-style scenarios. Exercise one covers creating multi-node DaemonSets with resource limits and exposed ports. Exercise two focuses on controlled rollout with OnDelete strategy, practicing the manual node-by-node update pattern. Exercise three explores node selection scenarios with different selectors and tolerations for various node types. Exercise four demonstrates init container setup with multiple chained init containers preparing the environment. Exercise five covers HostPath log collection with proper security settings. Exercise six shows debugging with pod affinity, co-locating debug Pods with DaemonSet Pods for troubleshooting.

Common CKAD scenarios round out your preparation. Deploying a monitoring agent involves running node-exporter on all nodes including masters, with hostNetwork and proper volume mounts. Fixing a broken update teaches you to identify image pull errors or configuration problems and resolve them quickly. Migrating from Deployment to DaemonSet shows how to convert existing workloads when requirements change to need one Pod per node. Scheduling on tainted nodes demonstrates how to add appropriate tolerations for nodes with special taints.

Best practices for CKAD emphasize practical exam approaches: choosing update strategies based on criticality, always setting resource limits, applying security contexts, using appropriate node selection methods, planning for high availability during updates, and monitoring DaemonSet health. These practices aren't just for the exam, they're how you should approach DaemonSets in production.

The quick reference commands give you a cheat sheet for rapid execution during the exam: creating, getting, describing, editing, updating, checking rollout status, viewing history, rolling back, deleting with or without cascade, getting Pods from DaemonSets, scaling by node labels, and manual Pod deletion for OnDelete strategy.

Remember, the CKAD exam tests pattern recognition as much as technical skill. When you see "ensure one instance runs on every node" or "deploy a monitoring agent cluster-wide," that's your signal for a DaemonSet. Practice converting Deployment specs to DaemonSet specs by changing the kind and removing the replicas field until this becomes automatic. The conversion is simple, but you need it to be fast and error-free under exam time pressure. Let's dive into these CKAD-specific DaemonSet scenarios and build your exam confidence!
