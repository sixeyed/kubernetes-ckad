Welcome back! Now that we've covered the fundamental concepts of DaemonSets, it's time to see them in action. We've discussed when to use DaemonSets versus Deployments, and how that decision matrix helps you choose the right workload controller for your needs. Now we're going to put that knowledge into practice and watch how DaemonSets behave in a real cluster.

In the upcoming exercises video, we're going to work through the API specs and create DaemonSets to see them automatically run on every node in your cluster. You'll start by deploying a DaemonSet with a HostPath volume, which is one of the most common patterns for node-level services that need to access resources specific to each node. We'll explore how multiple Pods running on the node might clash over resources, and how a DaemonSet prevents that by ensuring exactly one Pod per node.

As we progress, you'll see updating DaemonSets in action, which behaves differently from Deployments. Where Deployments start new Pods before removing old ones, DaemonSets remove Pods first before starting replacements, which can impact your application availability. We'll also work with Pods that have init containers, showing you how init containers run before the app container starts and can share volumes to prepare the environment. This pattern is incredibly useful for startup tasks like writing configuration files or setting up directories.

Then we'll dive into deploying to a subset of nodes using node selectors. You'll label nodes and use selectors to restrict DaemonSet Pods to specific nodes, watching how the DaemonSet controller automatically adjusts when node labels change. This is essential for scenarios where you only want your DaemonSet running on nodes with specific characteristics, like SSD storage or GPU capabilities.

The exercises also include a lab challenge where you'll practice two advanced features: manually controlling when Pods get replaced using update strategies, and deleting a DaemonSet while leaving its Pods intact. There's even an extra section on deploying a debug Pod to a DaemonSet node using Pod affinity rules, which demonstrates how to co-locate Pods on the same node for troubleshooting shared HostPath volumes.

Before starting the exercises video, make sure you have a Kubernetes cluster ready. The exercises work best with multiple nodes to see DaemonSets' full behavior, where you can watch Pods being distributed across your cluster. If you're using a single-node cluster like Docker Desktop, you'll still see the core concepts but with limited Pod distribution. You'll need kubectl installed and configured, and having a terminal and text editor ready will help you move quickly through the examples.

While DaemonSets are not as common as Deployments in typical application development, understanding them is crucial for cluster-wide services. You may encounter scenarios involving logging, monitoring, or node-level networking where DaemonSets are the appropriate solution. Beyond the immediate exercises, DaemonSets are essential for infrastructure services that every production cluster relies on: log shipping with fluentd or filebeat, metrics collection with node exporters, network plugins like Calico or Weave, and storage drivers for distributed filesystems.

The hands-on practice ahead will give you concrete experience with these patterns, showing you not just how to create DaemonSets, but how they behave when nodes are added or removed, when labels change, and when updates are applied. This practical understanding will serve you well both in the CKAD exam and in real-world cluster management. Let's get started with the hands-on exercises!
