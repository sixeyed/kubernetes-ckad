Welcome back! Now that we've covered the fundamental concepts of admission control in Kubernetes, it's time to see these mechanisms in action through hands-on practice.

In the upcoming exercises video, we're going to work with actual admission webhooks and policy enforcement tools. You'll deploy custom validation webhooks, watch them accept and reject resource requests, and see how mutating webhooks automatically modify your configurations. We'll also explore OPA Gatekeeper, which provides a more discoverable and maintainable approach to policy management compared to writing custom webhook code.

The exercises build up progressively through different admission control patterns. We'll start by setting up the infrastructure for secure webhook communication. Since admission webhooks must use HTTPS with trusted certificates, you'll deploy cert-manager to handle TLS certificate generation and rotation automatically. This is a common pattern in production Kubernetes environments, and understanding how webhook servers communicate securely over HTTPS is fundamental to working with admission control.

Once the certificate infrastructure is in place, we'll deploy a custom validating webhook that enforces a specific security policy. This webhook will require all Pods to explicitly disable automatic service account token mounting. You'll see how the webhook accepts compliant Pods while rejecting those that don't meet the policy. More importantly, you'll learn the critical troubleshooting skill of finding admission errors when deployments fail. These errors don't appear in Pod events where you might expect them - they show up in ReplicaSet events, which is often a source of confusion when debugging.

After working with validating webhooks, we'll explore mutating webhooks that automatically modify resources before they're persisted. You'll deploy a webhook that injects security contexts into all Pods, enforcing a non-root user policy. This is where things get interesting because you'll witness how automatic mutations can cause unexpected behavior. When the mutating webhook adds a runAsNonRoot requirement but the container image runs as root by default, you'll see CreateContainerConfigError failures. This demonstrates both the power and the potential pitfalls of automatic policy enforcement.

Then we'll transition to working with OPA Gatekeeper, which offers significant advantages over custom webhooks. Unlike custom webhook code that's essentially a black box, Gatekeeper policies are defined as Kubernetes resources that you can inspect and query with kubectl. You'll create constraint templates that define generic rules and then create specific constraints that apply those rules to your cluster. We'll work with policies for required labels and resource limits, seeing how Gatekeeper creates custom resource definitions for each constraint template, making policies discoverable and manageable through the standard Kubernetes API.

The lab challenge brings everything together. You'll need to deploy an application that must satisfy multiple Gatekeeper policies simultaneously - requiring specific labels on Pods and namespaces, and enforcing resource limits for containers. This exercise simulates real-world scenarios where multiple organizational policies must be satisfied, and you'll practice the essential skill of reading constraint requirements and adapting your manifests accordingly.

Throughout the exercises, we'll emphasize the cleanup procedures. Admission controllers operate at the cluster level, and OPA Gatekeeper installs custom resource definitions and webhooks that persist beyond individual namespaces. You'll learn the proper sequence for removing these components, including cleaning up constraint templates, webhook configurations, and custom resource definitions.

While admission control is advanced material beyond core CKAD requirements, understanding how it works is crucial for troubleshooting in real environments. When your deployments mysteriously fail during the exam or in production clusters, admission controllers are often the reason. Knowing where to look for admission errors, understanding ResourceQuota violations, and recognizing Pod Security Standard restrictions will save you valuable time. The exam won't ask you to implement admission controllers, but you must quickly diagnose when they block your deployments.

Make sure you have a running Kubernetes cluster with sufficient permissions to install cluster-scoped resources before starting. You'll need kubectl configured and the ability to deploy cert-manager, webhook servers, and OPA Gatekeeper. The exercises move at a comfortable pace with explanations of what's happening at each step. You can follow along on your own cluster, or watch first and practice afterward using the lab materials available in the repository.

Let's get started with the hands-on exercises and see admission control in action!
