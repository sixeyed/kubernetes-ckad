Excellent work on those hands-on exercises! You've now practiced configuring liveness, readiness, and startup probes, setting resource requests and limits, understanding quality of service classes, and implementing horizontal pod autoscaling. That practical experience gives you the foundation, but now we need to shift gears toward exam preparation. The CKAD exam tests production readiness patterns extensively, and you need to be able to implement these configurations quickly and correctly without looking up syntax or second-guessing yourself.

The exam requirements for productionizing cover a substantial amount of ground. You need to understand liveness, readiness, and startup probes with all three probe mechanisms - HTTP GET, TCP socket, and exec command probes. You'll configure resource requests and limits for both CPU and memory, and you need to know the difference between cores, millicores, and memory units like mebibytes and gibibytes. You should understand horizontal pod autoscaling based on CPU and memory metrics, though the autoscaling questions tend to be more about basic setup than advanced configuration. Security contexts at both pod and container level are essential, including running as non-root, setting read-only root filesystems, and managing Linux capabilities. You'll also encounter service accounts with RBAC basics, quality of service classes and how they affect eviction priority, resource quotas and limit ranges at the namespace level, pod disruption budgets for availability during voluntary disruptions, pod priority and preemption for critical workloads, and graceful termination with lifecycle hooks.

What makes the CKAD exam different from general Kubernetes learning is the emphasis on practical speed. When you see a requirement like "add a liveness probe that checks the health endpoint on port 8080," you need to instantly visualize the YAML structure with the httpGet path and port, the initial delay seconds, and the period seconds. When you're asked to "set CPU limit to 500 millicores and memory limit to 512 mebibytes," your fingers should already be typing the resources section with requests and limits before you've even thought about it consciously. This level of automaticity only comes from repeated practice with the actual YAML structures.

In the CKAD-focused material, we're going to drill on exam scenarios that test all aspects of production readiness. You'll work through health probe configurations covering all three types - liveness probes that restart containers on failure, readiness probes that control traffic routing to pods, and startup probes that give slow-starting applications time to initialize. Each probe type has specific use cases, and the exam expects you to choose the right one. You'll configure resource requests and limits across different scenarios, understanding that requests affect scheduling and quality of service assignment while limits prevent resource exhaustion but can cause CPU throttling or memory OOMKills.

The horizontal pod autoscaler exercises will show you how to use the kubectl autoscale command as a quick way to create HPAs, and you'll understand the relationship between resource requests and HPA target utilization. The autoscaler calculates desired replicas based on current CPU usage as a percentage of requested CPU, so without requests defined, the HPA can't function. We'll also cover the prerequisites like having metrics server installed and making sure your target resource is a deployment or other scalable controller.

Security contexts require careful attention because they can prevent pods from starting if not configured correctly. You'll practice running as non-root users, setting read-only root filesystems with appropriate writable volume mounts for directories the application needs, dropping all capabilities and selectively adding only required ones, and disabling service account token mounting when the application doesn't need Kubernetes API access. These security hardening steps are essential for production but require understanding which images support non-root execution and what directories need to be writable.

Beyond the individual configurations, you'll work through common CKAD scenarios that combine multiple concepts. Debugging a crashing container might involve examining aggressive liveness probes that restart the pod before it finishes initializing - the fix is adding a startup probe. Fixing OOMKilled pods requires analyzing memory usage and adjusting limits appropriately. When applications aren't receiving traffic despite having running pods, you'll check readiness probe configurations and service endpoints. If an HPA shows unknown metrics, you'll verify that resource requests are defined and metrics server is functioning. Security contexts that prevent startup often indicate image incompatibility or missing writable volumes for directories the application needs.

We'll also cover the lab exercises that appear in the CKAD materials, which go deeper than the basic README exercises. The complete health check implementation combines all three probe types with appropriate timing configuration for each. The resource management and quality of service exercise creates deployments demonstrating guaranteed, burstable, and best effort QoS classes and lets you verify their assignment. The HPA with load testing exercise includes a load generator that triggers scaling so you can observe the autoscaler in action. The security hardening exercise takes an insecure deployment and progressively adds all the security controls - non-root user, read-only filesystem, dropped capabilities, disabled token mounting, and resource limits. The production-ready application exercise combines everything into a single deployment that's truly ready for production with all three probe types, appropriate resources for burstable QoS, security contexts, HPA for autoscaling, multiple replicas, and a pod disruption budget.

The best practices for CKAD emphasize patterns you should internalize. For health probes, always use readiness probes in production, use liveness probes carefully to avoid false positives, add startup probes for slow-starting applications, and use different paths for different probe types so you can distinguish them. For resources, always set requests and limits, start conservative and tune based on monitoring, aim for burstable QoS for most applications but use guaranteed QoS for critical workloads. For autoscaling, set minimum replicas to at least two for availability, configure behavior for gradual scale-down to avoid flapping, and test HPA with realistic load. For security, run as non-root whenever possible, use read-only root filesystem, drop all capabilities and add only what's needed, and disable service account token auto-mounting unless the application needs Kubernetes API access. For availability, use multiple replicas, configure pod disruption budgets, set appropriate termination grace period seconds, and use pre-stop hooks for graceful shutdown.

The quick reference commands are your exam toolkit. You should know how to describe pods and grep for liveness or readiness probe information, how to use kubectl top to check resource usage, how to get QoS class from pod status, how to create HPAs with kubectl autoscale, how to check security contexts and service account configuration, how to view resource quotas and limit ranges, and how to check pod disruption budgets and test node draining. These commands help you verify configurations quickly during the exam.

Remember that production readiness patterns appear throughout the exam, not just in dedicated productionizing questions. When you're creating a deployment for any reason, you should be thinking about whether it needs health probes, what resources it requires, and whether security contexts are appropriate. These patterns should become second nature, part of your default approach to any pod specification. The syntax must be instant, the decisions must be automatic, and the verification must be quick. That's what we're building toward with this CKAD-focused material - production readiness as muscle memory, not as something you need to think about. Let's dive into the exam scenarios and drill until these patterns are effortless!
