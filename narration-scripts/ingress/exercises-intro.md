Welcome back! Now that we've covered the fundamental concepts of Ingress, what it is, how it provides HTTP and HTTPS routing, and why it's more efficient than multiple LoadBalancer Services, it's time to work with Ingress controllers and rules in practice.

In the upcoming exercises video, we're going to walk through the complete Ingress setup process, starting from nothing and building up to sophisticated routing patterns. The first thing we'll tackle is deploying an Ingress controller itself, which is the actual component that handles the routing. This is really important to understand because Ingress resources by themselves don't do anything, they're just configuration that tells the controller how to route traffic. We'll be using the NGINX Ingress Controller, but you'll also learn about other popular options like Traefik and Contour that work in similar ways.

Once we have the controller running, we'll explore the API specs for Ingress resources so you understand the structure of these objects and how they map to the routing behavior you're trying to achieve. Then we'll move into practical deployments, starting with publishing a default app through ingress. This default backend is really useful because it means users never see a raw 404 error from the ingress controller itself, they always get a friendly response even if they're hitting a URL that doesn't match any of your routing rules.

From there, we'll progress to publishing an app to a specific host address, which is where Ingress really starts to show its power. You'll see how to configure host-based routing so that requests for different domain names get routed to different backend Services, all through a single load balancer. This is the pattern that makes Ingress so cost-effective in production environments.

Next, we'll explore how to use ingress with response caching, which demonstrates how you can configure controller-specific features through annotations. This is a great example of how Ingress isn't just about routing, it can also add valuable middleware functionality like caching, compression, or rate limiting without any changes to your application code.

After working through these guided exercises, you'll encounter a lab challenge where you'll apply everything you've learned to configure ingress for a new application from scratch. This is your chance to practice the complete workflow without step-by-step instructions. If you want to push further into advanced territory, there's also an extra section on Ingress for HTTPS that covers TLS termination, SSL certificates, and secure routing patterns. Finally, we'll make sure you know how to properly clean up all the resources we've created.

Before starting the exercises video, make sure you have a Kubernetes cluster that can provision LoadBalancers or at least support port-forwarding, kubectl installed and configured, and a terminal and text editor ready to go. The exercises will guide you through the Ingress controller installation, but be aware that the specific steps can vary depending on whether you're using Docker Desktop, a cloud provider cluster, or a local cluster like kind or minikube.

Ingress is core CKAD exam content, and you'll definitely be asked to create Ingress resources with routing rules, possibly configure TLS, and troubleshoot routing issues when they're not working as expected. Beyond the exam, this is really how production Kubernetes clusters expose HTTP services efficiently. Using one LoadBalancer with routing rules is vastly more cost-effective and manageable than provisioning separate LoadBalancers for every Service in your cluster.

Let's get started with the hands-on exercises and see Ingress in action!
