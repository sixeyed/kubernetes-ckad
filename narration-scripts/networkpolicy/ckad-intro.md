Excellent work on the hands-on exercises! You've now practiced creating NetworkPolicies with ingress and egress rules, using pod and namespace selectors, and controlling traffic based on labels and ports. Here's what you need to know for CKAD: NetworkPolicy is core exam content, and you'll create policies to allow or deny specific traffic patterns. The exam expects you to understand NetworkPolicy syntax and translate security requirements into correct policy YAML. That's what we're going to focus on in this next section: exam-specific NetworkPolicy scenarios and rapid creation techniques.

The CKAD exam tests practical network security implementation, and you'll see requirements like allow traffic from frontend Pods to backend Pods on port eight zero eight zero, or deny all traffic to database Pods except from the app namespace. You need to translate these into NetworkPolicy YAML quickly. For NetworkPolicy specifically, the exam will test you on understanding the basics of how policies work at the Pod level using label selectors, defining ingress and egress rules, and knowing that rules are allow-lists with a whitelist model where multiple policies are additive. You need to understand that without any policy, all traffic is allowed, which is fundamentally different from what happens after you create your first policy.

You'll need to understand whether to use the imperative versus declarative approach. NetworkPolicy has no imperative create command, so you must write YAML. You can generate a template with dry-run output, but you'll need to edit it significantly. You'll use kubectl apply to create policies, kubectl get to list them, kubectl describe to see details, and kubectl delete to remove them. The shorthand netpol is commonly used instead of typing out networkpolicy every time.

Understanding default deny policies is critical because best practice is to start with default deny, then explicitly allow required traffic. You'll create deny all ingress policies with an empty pod selector that applies to all Pods and a policy type of Ingress with no ingress rules, which means deny all incoming traffic. You'll create deny all egress policies the same way but with policy type Egress. You'll create deny all ingress and egress policies that combine both types. The exam will expect you to deploy a default deny-all policy, deploy test pods, and verify they cannot communicate.

For ingress rules dealing with incoming traffic, you'll control traffic to Pods selected by the pod selector. You'll allow traffic from specific Pods using pod selector with match labels, which allows traffic to backend pods from frontend pods. You'll allow traffic from specific namespaces using namespace selector with match labels, which allows traffic to API pods from any pod in namespaces labeled with a team designation. You'll allow traffic from specific Pods in specific namespaces, and here's where it gets tricky: when namespace selector and pod selector are in the same list item, it's an AND condition where pods must match both selectors. When they're in separate list items with multiple dashes, they're OR conditions where traffic from either source is allowed. You'll allow traffic from IP blocks using CIDR notation, which allows traffic from a range except for specific addresses. You'll allow traffic on specific ports, restricting protocols and port numbers. The exam will expect you to create policies that allow ingress to API pods on port eight zero eight zero from web pods only.

For egress rules dealing with outgoing traffic, you'll control traffic from Pods selected by the pod selector. You'll allow traffic to specific Pods, you'll allow DNS which is critical for most apps, and you'll allow traffic to external IPs. Most applications need DNS, and if you have egress policies, you typically need to allow DNS explicitly to the kube-system namespace where CoreDNS runs on UDP port fifty-three. You'll allow traffic to external services using IP blocks with CIDR ranges, and you might want to block cloud metadata services at specific reserved addresses. You'll combine multiple egress rules together: allowing DNS to kube-system, allowing specific backend services on their ports, and allowing HTTPS to the internet on port four four three. The exam will expect you to create policies for frontend pods that allow egress to API pods on port eight zero eight zero and also allow DNS queries.

You'll need to know common CKAD patterns like the three-tier application pattern with web tier to API tier to database tier, where the database allows ingress from API only, the API allows ingress from web and egress to database, and the web allows ingress from anywhere and egress to API. You'll know the namespace isolation pattern that isolates namespaces from each other by creating policies where all pods in a namespace can only receive traffic from pods in the same namespace. You'll know the allow all ingress pattern with an empty ingress rule that means allow all, and the allow all egress pattern with an empty egress rule.

Testing NetworkPolicy is essential, and you'll test connectivity between pods using wget for HTTP with timeouts, curl with max time limits, netcat for checking any port, or ping for ICMP though it's often blocked by default. You'll test DNS resolution using nslookup to check if DNS works, to check service DNS, and to check cross-namespace service names. You'll debug NetworkPolicy by listing all policies across namespaces, describing policies to see which pods are selected, checking pod labels, and verifying if pods are affected by any policy.

The CKAD exam scenarios will include tasks like allowing web to API communication where you create a policy so web can access API on port eight zero eight zero, implementing namespace-level isolation where you create a policy that only allows traffic from pods within the same namespace, allowing only specific namespaces where you create a policy for API pods that allows ingress only from pods in namespaces labeled with an environment designation, managing database with multiple clients where you create a policy for database pods that allows ingress on port five four three two from both API and analytics pods, and handling egress with DNS where you create a policy that allows egress to API on port eight zero eight zero and also allows DNS queries.

As you advance, you'll encounter topics like named ports in NetworkPolicy, where you can reference ports by name as defined in the Pod spec instead of numbers. This is more maintainable because you change the port number in one place, it's self-documenting with port names that describe purpose, and it's flexible because different pods can use different port numbers for the same service. You'll understand combining multiple NetworkPolicies and how they're additive, combining with OR logic where there's no precedence or priority and all matching policies apply. The union of all rules means any policy allowing traffic permits it, and you cannot use one policy to deny what another allows. Order doesn't matter because policies are evaluated together. You'll work with NetworkPolicy for StatefulSets where StatefulSets have stable network identities and pods need to communicate with each other for replication and clustering. You'll use endPort for port ranges in Kubernetes one point twenty-two and later, which is useful for media streaming with RTP dynamic ports, FTP passive mode, database clusters with port ranges, and legacy applications with configurable port ranges.

Understanding common CKAD pitfalls is crucial because these trip up many candidates. Forgetting DNS means egress policies often block DNS causing unknown host errors. Empty pod selector meaning confusion arises because pod selector with empty braces means all pods, not none. AND versus OR confusion happens because the same list item equals AND while different items equal OR. Policy not enforced issues occur because not all clusters support NetworkPolicy, so you need to check your CNI. Service versus Pod confusion happens because NetworkPolicy works on Pods, not Services. The policy types requirement means if you specify policy types, you must list what you want controlled. Namespace labels are necessary because namespace selector needs namespaces to have labels. Bidirectional communication isn't automatic, so allowing traffic from A to B doesn't allow B to A and you need both policies. Port names require matching because using named ports requires matching container port names. CIDR for pod IPs is problematic because Pod IPs change, so you should use pod or namespace selectors instead.

You'll reference NetworkPolicy rules frequently, knowing that pod selector scope can be empty braces for all pods in current namespace or match labels for specific pods. Ingress from clauses can use pod selector for pods in the same namespace, namespace selector for all pods in matching namespaces, or IP block for IP ranges, and these are OR conditions. Ingress from with AND condition puts namespace selector and pod selector in the same list item where pods must match both. Egress to clauses work the same as ingress with pod selector, namespace selector, and IP block. Port specifications include protocol as TCP or UDP, port as the target port number, and optionally end port for port ranges in version one point twenty-two and later.

The quick reference commands you'll use constantly include kubectl get networkpolicy or the shorthand netpol, with the option for all namespaces. You'll describe policies to see their configuration, get policy YAML to view the full specification, and delete policies when needed. You'll test connectivity with kubectl exec running wget with timeouts or netcat to check specific ports. You'll check pod labels for troubleshooting with show-labels, and you'll check namespace labels the same way.

Finally, you'll work through practice exercises that simulate the exam experience. Exercise one is a complete three-tier application where you deploy web, API, and database with a default deny-all policy, configure web to accept traffic from anywhere on port eighty and connect to API on port eight zero eight zero, configure API to accept traffic from web only and connect to database on port five four three two, configure database to accept traffic from API only, and ensure all pods can access DNS. Exercise two is cross-namespace communication where you create frontend and backend namespaces, label the backend namespace, deploy apps in both namespaces, create NetworkPolicy allowing frontend app to access backend API, and verify communication works across namespaces. Exercise three is egress restriction where you create a policy that applies to restricted pods, allows egress to internal services only using the ten dot zero dot zero dot zero slash eight CIDR range, blocks all external traffic, and allows DNS.

Remember that NetworkPolicy syntax is specific and must be exact. The difference between pod selector in the policy spec versus pod selector in ingress or egress rules is crucial: one selects which Pods the policy applies to, the other selects which Pods are allowed to communicate. Practice NetworkPolicy creation until the structure is muscle memory. When you see allow traffic from frontend to backend on port eight zero eight zero, you should immediately visualize the correct YAML structure with the policy applying to backend pods, the ingress from frontend pods, and the ports specification with TCP protocol and port eight zero eight zero. Let's dive into CKAD-specific NetworkPolicy scenarios!
